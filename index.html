<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Atlântico Golf — Cronograma (11/Set)</title>
    <!-- Tailwind (CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React 18 (UMD) + Babel (para JSX no navegador) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      html,body{height:100%; background:#f5f7fb; color:#111827}
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      // =============================
      // Atlântico Golf — Cronograma v3 (página estática)
      // LOGO: apenas via arquivo no repositório (ex.: ./logo.jpg ou ./assets/logo.png).
      // Não há mais campos/controles na página para subir ou informar URL.
      // =============================

      const { useMemo, useState, useEffect } = React;

      // Utils de datas
      const d = (s) => new Date(s + "T00:00:00");
      const fmt = (date) => date.toLocaleDateString("pt-BR", { timeZone: "America/Sao_Paulo" });
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const daysBetween = (a,b) => Math.max(0, Math.round((b - a) / (24*3600*1000)));

      // Janela / Hoje
      const WINDOW_START = d("2025-06-02");
      const WINDOW_END   = d("2026-01-30");
      const MS = 24 * 3600 * 1000;
      const TODAY = new Date();

      // Paleta
      const COLORS = {
        base: "#0e3a6d",
        bar: "#2b8ccc",
        done: "#16a34a",
        wait: "#ca8a04",
        risk: "#b91c1c",
        hold: "#9333ea",
        grid: "#e2e8f0",
        text: "#111827",
        bg:   "#f5f7fb",
        card: "#ffffff",
        border: "#cbd5e1",
      };

      // Dados (resumo)
      const tasks = [
        { id: 0, bloco: "Geral", nome: "Atlântico Golf (Projeto)", inicio: "2025-06-02", fim: "2026-01-30", pct: 27, obs: "Escopo total" },
        // Bloco 1
        { id: 1, bloco: "Bloco 1", nome: "Entrada de Energia", inicio: "2025-06-02", fim: "2025-12-24", pct: 11 },
        { id: 3, bloco: "Bloco 1", nome: "Alimentadores entre Cofres e PDMDs", inicio: "2025-11-10", fim: "2025-12-24", pct: 0, obs: "Aguardando cabos da Patrimar" },
        { id: 4, bloco: "Bloco 1", nome: "Instalação Painéis Padrão Light (Térreo)", inicio: "2025-11-10", fim: "2025-12-24", pct: 0, obs: "Aguardando chegada dos painéis" },
        { id: 5, bloco: "Bloco 1", nome: "Infra entre Painéis Light (Térreo ↔ Subsolo)", inicio: "2025-11-10", fim: "2025-12-24", pct: 0 },
        { id: 6, bloco: "Bloco 1", nome: "Lançamento de Alimentadores Painéis Light", inicio: "2025-10-01", fim: "2025-10-07", pct: 0, obs: "Depende de painéis" },
        { id: 7, bloco: "Bloco 1", nome: "Fechamento de Alimentadores Painéis Light", inicio: "2025-10-08", fim: "2025-10-13", pct: 0, obs: "Depende de painéis" },
        { id: 8, bloco: "Bloco 1", nome: "Conclusão Barramentos Blindados", inicio: "2025-08-01", fim: "2025-08-22", pct: 95, obs: "Aguardando desobstrução de trechos" },
        { id: 9, bloco: "Bloco 1", nome: "Ligação Barramentos → Painéis Light", inicio: "2025-08-01", fim: "2025-08-07", pct: 0, obs: "Depende de painéis" },
        { id: 10, bloco: "Bloco 1", nome: "Peças em Hold dos Barramentos", inicio: "2025-08-20", fim: "2025-09-05", pct: 0, obs: "Aguardando" },
        // Bloco 2
        { id: 12, bloco: "Bloco 2", nome: "Instalações Elétricas/Especiais/SPDA/Entrada", inicio: "2025-06-02", fim: "2026-01-16", pct: 54 },
        { id: 14, bloco: "Bloco 2", nome: "Interruptores e Tomadas (Aptos)", inicio: "2025-06-02", fim: "2025-07-28", pct: 95 },
        { id: 15, bloco: "Bloco 2", nome: "Interruptores/Tomadas Térreo e Telhado", inicio: "2025-06-30", fim: "2025-07-24", pct: 80, obs: "Aguardando chegada dos interruptores" },
        { id: 16, bloco: "Bloco 2", nome: "QDLs Aptos + Fechamento de Circuitos", inicio: "2025-06-02", fim: "2025-09-26", pct: 70, obs: "Faltando material / verificar estoque" },
        { id: 18, bloco: "Bloco 2", nome: "Alimentadores PDMDs → Aptos (furtados)", inicio: "2025-06-23", fim: "2025-12-19", pct: 30 },
        { id: 19, bloco: "Bloco 2", nome: "SPDA – Barra Chata", inicio: "2025-07-14", fim: "2025-10-17", pct: 60, obs: "Aguardando liberação Patrimar" },
        { id: 20, bloco: "Bloco 2", nome: "Caixas de Painéis Áreas Comuns", inicio: "2025-06-02", fim: "2025-11-14", pct: 60, obs: "Prazo mediante liberação de área (meados/11)" },
        { id: 21, bloco: "Bloco 2", nome: "Fechamento Infra Painéis Áreas Comuns", inicio: "2025-06-02", fim: "2025-11-14", pct: 50, obs: "Acompanha caixas" },
        { id: 22, bloco: "Bloco 2", nome: "Fechamento Alimentadores/Circuitos – Áreas Comuns", inicio: "2025-09-01", fim: "2025-11-21", pct: 70, obs: "Aguardando miolos dos painéis" },
        { id: 23, bloco: "Bloco 2", nome: "Instalação Painéis Padrão Light (Térreo)", inicio: "2025-11-03", fim: "2025-11-07", pct: 0 },
        { id: 24, bloco: "Bloco 2", nome: "Infra Painéis Light (Térreo ↔ Subsolo)", inicio: "2025-11-10", fim: "2025-11-14", pct: 0 },
        { id: 25, bloco: "Bloco 2", nome: "Lançamento Alimentadores Painéis Light", inicio: "2025-11-03", fim: "2025-11-10", pct: 0, obs: "Depende dos cabos" },
        { id: 26, bloco: "Bloco 2", nome: "Fechamento Alimentadores Painéis Light", inicio: "2025-11-17", fim: "2025-11-20", pct: 0, obs: "Depende dos cabos" },
        { id: 27, bloco: "Bloco 2", nome: "Conclusão Barramentos Blindados", inicio: "2025-08-01", fim: "2026-01-09", pct: 80 },
        { id: 28, bloco: "Bloco 2", nome: "Ligação Barramentos → Painéis Light", inicio: "2026-01-12", fim: "2026-01-16", pct: 0 },
        { id: 29, bloco: "Bloco 2", nome: "Cabeamentos Automáticos de Boia (sup.)", inicio: "2025-10-15", fim: "2025-10-30", pct: 60, obs: "Cabo furtado nas duas torres" },
        { id: 30, bloco: "Bloco 2", nome: "Luminárias Áreas Comuns", inicio: "2025-10-06", fim: "2025-10-24", pct: 0 },
        { id: 31, bloco: "Bloco 2", nome: "Entregas para Qualidade (aptos)", inicio: "2025-09-10", fim: "2025-12-26", pct: 0 },
        // Bloco 3
        { id: 49, bloco: "Bloco 3", nome: "Instalações Elétricas/Especiais/SPDA/Entrada", inicio: "2025-06-02", fim: "2026-01-16", pct: 47 },
        { id: 50, bloco: "Bloco 3", nome: "Interruptores e Tomadas (Aptos)", inicio: "2025-06-02", fim: "2025-07-28", pct: 95 },
        { id: 51, bloco: "Bloco 3", nome: "Interruptores/Tomadas Térreo e Telhado", inicio: "2025-06-30", fim: "2025-07-24", pct: 80, obs: "Aguardando chegada dos interruptores" },
        { id: 52, bloco: "Bloco 3", nome: "QDLs Aptos + Fechamento de Circuitos", inicio: "2025-06-02", fim: "2025-09-26", pct: 70 },
        { id: 54, bloco: "Bloco 3", nome: "Alimentadores PDMDs → Aptos (furtados)", inicio: "2025-06-23", fim: "2025-12-19", pct: 30 },
        { id: 55, bloco: "Bloco 3", nome: "SPDA – Barra Chata", inicio: "2025-07-14", fim: "2025-10-17", pct: 60 },
        { id: 56, bloco: "Bloco 3", nome: "Caixas de Painéis Áreas Comuns", inicio: "2025-06-02", fim: "2025-11-14", pct: 80 },
        { id: 57, bloco: "Bloco 3", nome: "Fechamento Infra Painéis Áreas Comuns", inicio: "2025-06-02", fim: "2025-11-14", pct: 50 },
        { id: 58, bloco: "Bloco 3", nome: "Fechamento Alimentadores/Circuitos – Áreas Comuns", inicio: "2025-09-01", fim: "2025-11-21", pct: 70, obs: "Aguardando miolos dos painéis" },
        { id: 59, bloco: "Bloco 3", nome: "Instalação Painéis Padrão Light (Térreo)", inicio: "2025-11-03", fim: "2025-11-07", pct: 0 },
        { id: 60, bloco: "Bloco 3", nome: "Infra Painéis Light (Térreo ↔ Subsolo)", inicio: "2025-11-10", fim: "2025-11-14", pct: 0 },
        { id: 61, bloco: "Bloco 3", nome: "Lançamento Alimentadores Painéis Light", inicio: "2025-11-03", fim: "2025-11-10", pct: 0 },
        { id: 62, bloco: "Bloco 3", nome: "Fechamento Alimentadores Painéis Light", inicio: "2025-11-17", fim: "2025-11-20", pct: 0 },
        { id: 63, bloco: "Bloco 3", nome: "Ligação Barramentos → Painéis Light", inicio: "2025-08-01", fim: "2026-01-09", pct: 0 },
        { id: 64, bloco: "Bloco 3", nome: "Infra Medição Remota Light", inicio: "2025-10-15", fim: "2025-10-30", pct: 60, obs: "Cabo furtado nas duas torres" },
        { id: 65, bloco: "Bloco 3", nome: "Conclusão Barramentos Blindados", inicio: "2026-01-12", fim: "2026-01-16", pct: 80 },
        { id: 66, bloco: "Bloco 3", nome: "Cofres do Busway", inicio: "2025-06-02", fim: "2025-07-18", pct: 90 },
        { id: 68, bloco: "Bloco 3", nome: "Busway", inicio: "2025-06-06", fim: "2025-06-06", pct: 90 },
        { id: 69, bloco: "Bloco 3", nome: "Luminárias Áreas Comuns", inicio: "2025-08-04", fim: "2025-08-23", pct: 0 },
        { id: 70, bloco: "Bloco 3", nome: "Entregas para Qualidade (aptos)", inicio: "2025-09-10", fim: "2025-12-26", pct: 0 },
        // Hidros/Gás (resumo)
        { id: 71, bloco: "Bloco 3", nome: "Instalações Hidrossanitárias e Gás", inicio: "2025-06-02", fim: "2026-01-30", pct: 64 },
        { id: 72, bloco: "Geral", nome: "Louças (aptos)", inicio: "2025-06-02", fim: "2025-06-13", pct: 95, obs: "Aguardando coberturas" },
        { id: 75, bloco: "Geral", nome: "Metais/Acabamentos (aptos)", inicio: "2025-07-28", fim: "2025-09-15", pct: 40, obs: "Entregas parciais/desorganizadas; pendente canoplas e sifões" },
        { id: 83, bloco: "Geral", nome: "Verificações Finais (geral)", inicio: "2026-01-05", fim: "2026-01-30", pct: 0 },
        // Embasamento
        { id: 84, bloco: "Embasamento", nome: "Embasamento – Térreo/Subsolo (geral)", inicio: "2025-06-02", fim: "2026-01-30", pct: 32 },
        { id: 88, bloco: "Embasamento", nome: "Cabeamento p/ Iluminação Externa", inicio: "2025-10-06", fim: "2025-12-19", pct: 0, obs: "Aguardando definição de aditivo" },
        { id: 93, bloco: "Embasamento", nome: "Luminárias de Emergência", inicio: "2025-11-17", fim: "2025-11-28", pct: 0, obs: "Aguardando compras/suprimentos" },
        // Pacote Light
        { id: 97, bloco: "Pacote Light", nome: "Barramentos Blindados (janela 1)", inicio: "2025-08-01", fim: "2025-08-07", pct: 80 },
        { id: 98, bloco: "Pacote Light", nome: "Totalizadoras Light", inicio: "2025-08-04", fim: "2025-10-30", pct: 0 },
        { id: 103, bloco: "Pacote Light", nome: "Lançamento Cabos Alimentadores Subsolo", inicio: "2025-08-08", fim: "2025-12-15", pct: 25 },
      ];

      // Status
      function statusFrom(t){
        const o = (t.obs||"").toLowerCase();
        if (/(hold|não liberado)/.test(o)) return { k:"hold", label:"Hold/Não liberado" };
        if (/(aguardando|depende|furto|furtado)/.test(o)) return { k:"wait", label:"Aguardando/Dependência" };
        if ((new Date(t.fim) < TODAY) && (t.pct ?? 0) < 100) return { k:"overdue", label:"Em atraso" };
        if (t.pct>=100) return { k:"done", label:"Concluído" };
        return { k:"inprog", label:"Em execução" };
      }

      function barColor(t){
        const s = statusFrom(t).k;
        if (s === "done") return COLORS.done;
        if (s === "wait") return COLORS.wait;
        if (s === "hold") return COLORS.hold;
        return COLORS.bar;
      }

      // Barra Gantt
      function GanttBar({ task, spanDays, compact }){
        const start = d(task.inicio);
        const end   = d(task.fim);
        const left = clamp(((start - WINDOW_START)/MS)/spanDays * 100, -5, 105);
        const width = clamp(((end - start)/MS)/spanDays * 100, 0.2, 120);
        const pc = clamp(task.pct ?? 0, 0, 100);
        const color = barColor(task);
        const todayLeft = clamp(((TODAY - WINDOW_START)/MS)/spanDays * 100, -5, 105);
        const overdue = (TODAY > end) && pc < 100;
        const h = compact ? 22 : 28;

        return (
          <div className="group relative w-full">
            {/* Linha de hoje */}
            <div className="absolute" style={{left: `${todayLeft}%`, top: 0, bottom: 0}}>
              <div style={{width:2, background:"#11182722", height:"100%"}} />
            </div>

            {/* Barra */}
            <div className="relative rounded-xl shadow-sm" style={{
              position: "relative",
              left: `${left}%`,
              width: `${width}%`,
              background: color,
              height: h,
              outline: overdue ? `2px solid ${COLORS.risk}` : "none",
            }}>
              {/* Preenchimento de avanço */}
              <div style={{ width: `${pc}%`, background: "#00000022", height: "100%", borderRadius: 12 }} />
              <div className="absolute inset-0 flex items-center px-3 text-white text-[12px] font-medium drop-shadow">
                <span className="truncate">{task.nome}</span>
                <span className="ml-2 opacity-80">• {pc}%</span>
              </div>
            </div>

            {/* Sub-infos */}
            <div className="mt-1 text-[11px] text-slate-600 flex flex-wrap items-center gap-2">
              <span>{fmt(start)} → {fmt(end)}</span>
              {task.obs && <span className="italic">· {task.obs}</span>}
              {overdue && (
                <span className="px-2 py-0.5 rounded-full text-white" style={{background: COLORS.risk}}>
                  {daysBetween(end, TODAY)}d em atraso
                </span>
              )}
            </div>
          </div>
        );
      }

      // Cabeçalho de meses (sticky)
      function MonthHeader({ spanDays }){
        const months = [];
        let cursor = new Date(WINDOW_START);
        cursor.setDate(1);
        while (cursor <= WINDOW_END){
          const mStart = new Date(cursor);
          const mEnd = new Date(cursor.getFullYear(), cursor.getMonth()+1, 0);
          const start = Math.max(mStart, WINDOW_START);
          const end = Math.min(mEnd, WINDOW_END);
          const width = ((end - start)/MS)/spanDays * 100;
          months.push({ key: `${cursor.getFullYear()}-${cursor.getMonth()}`, label: mStart.toLocaleDateString("pt-BR", { month: "short", year: "2-digit" }), width });
          cursor = new Date(cursor.getFullYear(), cursor.getMonth()+1, 1);
        }
        return (
          <div className="flex w-full select-none sticky top-0 z-10" style={{gap:2, background: COLORS.card, borderBottom: `1px solid ${COLORS.border}`}}>
            {months.map(m => (
              <div key={m.key} className="text-[11px] uppercase tracking-wide text-slate-600 text-center" style={{width:`${m.width}%`}}>
                {m.label}
              </div>
            ))}
          </div>
        );
      }

      // Legenda
      function Legend(){
        const Item = ({c, t}) => (
          <div className="flex items-center gap-2 text-[12px]">
            <span className="inline-block w-3 h-3 rounded" style={{background:c}} /> {t}
          </div>
        );
        return (
          <div className="flex flex-wrap gap-4">
            <Item c={COLORS.bar} t="Em execução" />
            <Item c={COLORS.done} t="Concluído" />
            <Item c={COLORS.wait} t="Aguardando/Dependência" />
            <Item c={COLORS.hold} t="Hold/Não liberado" />
            <Item c={COLORS.risk} t="Em atraso" />
          </div>
        );
      }

      const STATUS_ORDER = ["Todos","inprog","wait","hold","overdue","done"];
      const STATUS_LABEL = { inprog: "Em execução", wait: "Aguardando", hold: "Hold", overdue: "Em atraso", done: "Concluído" };

      // Candidatos de logo locais (tentativa automática, sem controles na UI)
      const LOGO_CANDIDATES = [
        './logo.jpg','./logo.png','./logo.svg',
        './assets/logo.jpg','./assets/logo.png','./assets/logo.svg'
      ];

      // Componente simples que tenta exibir um logo local se existir
      function LogoImage({ size = 48 }){
        const [idx, setIdx] = useState(0);
        const [src, setSrc] = useState(LOGO_CANDIDATES[0]);
        useEffect(()=>{ setSrc(LOGO_CANDIDATES[0]); }, []);
        const onError = () => {
          if (idx < LOGO_CANDIDATES.length - 1){
            const next = idx + 1;
            setIdx(next);
            setSrc(LOGO_CANDIDATES[next]);
          } else {
            setSrc(''); // não mostra nada se não encontrar
          }
        };
        if (!src) return null;
        return <img src={src} onError={onError} alt="logo" style={{height: size, width: 'auto'}} />;
      }

      // Filtros (sem qualquer item de logo)
      function Filters({ all, onFilter, compact, setCompact, zoom, setZoom }){
        const [txt, setTxt] = useState("");
        const [bloco, setBloco] = useState("Todos");
        const [status, setStatus] = useState("Todos");
        const blocos = useMemo(() => ["Todos", ...Array.from(new Set(all.map(t=>t.bloco)))], [all]);

        return (
          <div className="flex flex-wrap items-end gap-3">
            <div className="flex flex-col">
              <label className="text-[12px] text-slate-600 mb-1">Busca</label>
              <input className="px-3 py-2 rounded-lg border outline-none" placeholder="Digite tarefa, observação..." value={txt} onChange={e=>setTxt(e.target.value)} />
            </div>
            <div className="flex flex-col">
              <label className="text-[12px] text-slate-600 mb-1">Bloco</label>
              <select className="px-3 py-2 rounded-lg border" value={bloco} onChange={e=>setBloco(e.target.value)}>
                {blocos.map(b => <option key={b}>{b}</option>)}
              </select>
            </div>
            <div className="flex flex-col">
              <label className="text-[12px] text-slate-600 mb-1">Status</label>
              <select className="px-3 py-2 rounded-lg border" value={status} onChange={e=>setStatus(e.target.value)}>
                {STATUS_ORDER.map(s => <option key={s} value={s}>{s==="Todos"?"Todos":STATUS_LABEL[s]}</option>)}
              </select>
            </div>
            <button className="px-4 py-2 rounded-xl bg-[#0e3a6d] text-white shadow" onClick={()=>onFilter({ txt, bloco, status })}>Aplicar</button>
            <button className="px-4 py-2 rounded-xl border" onClick={()=>{ setTxt(""); setBloco("Todos"); setStatus("Todos"); onFilter({ txt:"", bloco:"Todos", status:"Todos"}); }}>Limpar</button>

            {/* Zoom */}
            <div className="flex items-center gap-2 ml-4">
              <label className="text-[12px] text-slate-600">Zoom</label>
              <input type="range" min={25} max={200} value={zoom} onChange={e=>setZoom(Number(e.target.value))} />
              <span className="text-[12px] text-slate-600">{zoom}%</span>
            </div>

            {/* Modo compacto */}
            <label className="flex items-center gap-2 ml-2 text-[12px] text-slate-600">
              <input type="checkbox" checked={compact} onChange={e=>setCompact(e.target.checked)} /> Modo compacto
            </label>
          </div>
        );
      }

      function GroupHeader({ title, tasks }){
        const arr = tasks.map(t => ({ days: Math.max(1, daysBetween(d(t.inicio), d(t.fim))), pct: clamp(t.pct??0,0,100) }));
        const totalDays = arr.reduce((s,x)=>s+x.days,0);
        const w = arr.reduce((s,x)=>s + x.days * x.pct, 0);
        const pv = totalDays? Math.round(w/totalDays): 0;
        const overdueCount = tasks.filter(t => (new Date(t.fim) < TODAY) && (t.pct??0) < 100).length;
        return (
          <div className="flex items-center justify-between px-3 py-2 bg-slate-50 border-b" style={{borderColor: COLORS.border}}>
            <div className="font-semibold">{title}</div>
            <div className="flex items-center gap-3 text-[12px] text-slate-600">
              <span>Tarefas: <b>{tasks.length}</b></span>
              <span>Progresso (pond.): <b>{pv}%</b></span>
              <span className="px-2 py-0.5 rounded-full" style={{background: overdueCount?"#fee2e2":"#e2e8f0", color: overdueCount?"#991b1b":"#334155"}}>Atraso: {overdueCount}</span>
            </div>
          </div>
        );
      }

      function TaskLeft({ t }){
        const s = statusFrom(t);
        const chipBg = { inprog: "#ebf3ff", wait: "#fff7e6", hold: "#f3e8ff", overdue: "#fee2e2", done: "#e6f7ec" }[s.k] || "#ebf3ff";
        const chipTx = { inprog: "#1e3a8a", wait: "#92400e", hold: "#6b21a8", overdue: "#991b1b", done: "#166534" }[s.k] || "#1e3a8a";
        return (
          <div className="pr-4">
            <div className="text-[12px] text-slate-500">{t.bloco}</div>
            <div className="font-medium flex items-center gap-2">
              {t.nome}
              <span className="px-2 py-0.5 rounded-full text-[11px]" style={{background: chipBg, color: chipTx}}>{s.label}</span>
            </div>
            {t.obs && <div className="text-[12px] italic mt-1 text-slate-600">{t.obs}</div>}
          </div>
        );
      }

      function App(){
        const [filter, setFilter] = useState({ txt:"", bloco:"Todos", status:"Todos" });
        const [zoom, setZoom] = useState(100);
        const [compact, setCompact] = useState(false);

        const spanDaysBase = Math.max(1, Math.round((WINDOW_END - WINDOW_START) / MS));
        const spanDays = Math.round(spanDaysBase / (zoom / 100));

        const filtered = useMemo(() => {
          const q = filter.txt.trim().toLowerCase();
          return tasks.filter(t => {
            const blocook = filter.bloco === "Todos" || t.bloco === filter.bloco;
            const textok = !q || (t.nome.toLowerCase().includes(q) || (t.obs||"").toLowerCase().includes(q));
            const s = statusFrom(t).k;
            const statusok = filter.status === "Todos" || s === filter.status;
            return blocook && textok && statusok;
          }).sort((a,b)=> d(a.inicio) - d(b.inicio));
        }, [filter]);

        const groups = useMemo(() => {
          const map = new Map();
          filtered.forEach(t => {
            if (!map.has(t.bloco)) map.set(t.bloco, []);
            map.get(t.bloco).push(t);
          });
          return Array.from(map.entries()).sort(([a],[b]) => a.localeCompare(b));
        }, [filtered]);

        const progressoGeral = useMemo(() => {
          const arr = tasks.map(t => ({ days: Math.max(1, Math.round((d(t.fim)-d(t.inicio))/MS)), pct: clamp(t.pct??0,0,100) }));
          const totalDays = arr.reduce((s,x)=>s+x.days,0);
          const w = arr.reduce((s,x)=>s + x.days * x.pct, 0);
          return Math.round(w/totalDays);
        }, []);

        return (
          <div className="min-h-screen" style={{background: COLORS.bg, color: COLORS.text}}>
            <div className="max-w-7xl mx-auto px-4 py-6">
              <header className="flex flex-wrap items-center justify-between gap-4 mb-4">
                <div className="flex items-center gap-3">
                  <LogoImage size={48} />
                  <div>
                    <h1 className="text-2xl font-extrabold">Atlântico Golf — Cronograma (11/Set)</h1>
                    <p className="text-slate-600">Janela: {fmt(WINDOW_START)} → {fmt(WINDOW_END)} · Progresso médio ponderado: <b>{progressoGeral}%</b></p>
                  </div>
                </div>
                <div className="flex flex-col items-end">
                  <Legend />
                  <div className="text-[12px] text-slate-600 mt-1">Linha vertical indica <b>hoje</b>: {fmt(TODAY)}</div>
                </div>
              </header>

              <section className="mb-4">
                <Filters all={tasks} onFilter={setFilter} compact={compact} setCompact={setCompact} zoom={zoom} setZoom={setZoom} />
              </section>

              <section className="rounded-2xl shadow-xl border overflow-hidden" style={{background: COLORS.card, borderColor: COLORS.border}}>
                <MonthHeader spanDays={Math.max(1, Math.round((WINDOW_END - WINDOW_START) / MS) / (zoom / 100))} />

                {groups.map(([bloco, itens]) => (
                  <div key={bloco} className="border-b" style={{borderColor: COLORS.border}}>
                    <div className="flex items-center justify-between">
                      <GroupHeader title={bloco} tasks={itens} />
                    </div>
                    <div className="divide-y" style={{borderColor: COLORS.border}}>
                      {itens.map(t => (
                        <div key={t.id} className="p-3 grid" style={{gridTemplateColumns: '260px 1fr'}}>
                          <TaskLeft t={t} />
                          <div>
                            <GanttBar task={t} spanDays={Math.max(1, Math.round((WINDOW_END - WINDOW_START) / MS) / (zoom / 100))} compact={compact} />
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                ))}
              </section>

              <section className="mt-6">
                <details className="rounded-xl border p-4 bg-white">
                  <summary className="cursor-pointer font-semibold">Ver tabela (dados brutos)</summary>
                  <div className="overflow-x-auto mt-3">
                    <table className="min-w-full text-sm">
                      <thead>
                        <tr className="text-left border-b">
                          <th className="py-2 pr-4">ID</th>
                          <th className="py-2 pr-4">Bloco</th>
                          <th className="py-2 pr-4">Tarefa</th>
                          <th className="py-2 pr-4">Início</th>
                          <th className="py-2 pr-4">Término</th>
                          <th className="py-2 pr-4">% Concl.</th>
                          <th className="py-2 pr-4">Status</th>
                          <th className="py-2 pr-4">Observação</th>
                        </tr>
                      </thead>
                      <tbody>
                        {tasks.map(t => {
                          const s = statusFrom(t);
                          return (
                            <tr key={`tb-${t.id}`} className="border-b last:border-0">
                              <td className="py-1 pr-4">{t.id}</td>
                              <td className="py-1 pr-4">{t.bloco}</td>
                              <td className="py-1 pr-4">{t.nome}</td>
                              <td className="py-1 pr-4">{t.inicio}</td>
                              <td className="py-1 pr-4">{t.fim}</td>
                              <td className="py-1 pr-4">{t.pct}%</td>
                              <td className="py-1 pr-4">{s.label}</td>
                              <td className="py-1 pr-4">{t.obs||""}</td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  </div>
                </details>
              </section>

              <footer className="mt-8 text-[12px] text-slate-500">
                <div>• Para exibir um logo, adicione <b>logo.jpg</b> (ou <code>logo.png</code>/<code>logo.svg</code>) na raiz do repo. Alternativamente use <code>assets/logo.*</code>.</div>
                <div>• O app tenta carregar automaticamente nessas ordens; se não encontrar, o espaço do logo permanece vazio.</div>
                <div>• GitHub Pages: publique como <b>index.html</b> na raiz (ou em <code>/docs</code>) e ative em <b>Settings → Pages</b>.</div>
              </footer>
            </div>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>
