
<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Woods & Ox Park — Cronograma</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
      html,body{height:100%;background:#f5f7fb;color:#111827}
      /* Tipografia enxuta */
      body{font-feature-settings:"tnum" 1, "ss01" 1}
    </style>
  </head>
  <body class="text-[12px]">
    <div id="root"></div>

    <script type="text/babel">
      const { useMemo, useState, useEffect } = React;

      // ===== Helpers =====
      const d = (s) => new Date((s||"").replace(/\//g,'-').replace(/(\d{2})-(\d{2})-(\d{4})/,'$3-$2-$1') + (s?.includes('T')?'':'T00:00:00'));
      const fmt = (date) => date instanceof Date && !isNaN(date) ? date.toLocaleDateString("pt-BR", { timeZone: "America/Sao_Paulo" }) : '';
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const daysBetween = (a,b) => Math.max(0, Math.round((b - a) / (24*3600*1000)));
      const TODAY = new Date();
      const MS = 24*3600*1000;

      // Janela padrão (ajustada ao CSV quando carregado)
      const DEFAULT_START = new Date('2025-06-02T00:00:00');
      const DEFAULT_END   = new Date('2026-01-30T00:00:00');

      const COLORS = {
        base:"#0e3a6d", bar:"#2b8ccc", done:"#16a34a", wait:"#ca8a04", risk:"#b91c1c", hold:"#9333ea",
        grid:"#e2e8f0", text:"#111827", bg:"#f5f7fb", card:"#ffffff", border:"#cbd5e1"
      };

      // ===== Status =====
      function statusFrom(t){
        const o = (t.obs||"").toLowerCase();
        if (/(hold|não liberado)/.test(o)) return { k:"hold", label:"Hold/Não liberado" };
        if (/(aguardando|depende|furtad)/.test(o)) return { k:"wait", label:"Aguardando/Dependência" };
        if ((new Date(t.fim) < TODAY) && (t.pct ?? 0) < 100) return { k:"overdue", label:"Em atraso" };
        if ((t.pct ?? 0) >= 100) return { k:"done", label:"Concluído" };
        return { k:"inprog", label:"Em execução" };
      }
      function barColor(t){
        const s = statusFrom(t).k;
        if (s==="done") return COLORS.done;
        if (s==="wait") return COLORS.wait;
        if (s==="hold") return COLORS.hold;
        if (s==="overdue") return COLORS.bar;
        return COLORS.bar;
      }

      // ===== CSV → tasks =====
      const nameToBloco = (nome='') => {
        const n = nome.toLowerCase();
        if (/bloco\s*1/.test(n)) return 'Bloco 1';
        if (/bloco\s*2/.test(n)) return 'Bloco 2';
        if (/bloco\s*3/.test(n)) return 'Bloco 3';
        if (/embas|subsolo|térreo|terreo|reservat|piscina|externa/.test(n)) return 'Embasamento';
        return 'Todos';
      };
      const isEnergyB1 = (x) => x.bloco === 'Bloco 1' && /energia|pain[eé]is\s*light|barrament|alimentador|cofre|pdmd|interlig|entrada|totalizadora|busway/i.test(x.nome||'');

      function autodetectColumns(header){
        const idx = (keys) => header.findIndex(h => keys.some(k => new RegExp(k, 'i').test(h)));
        return {
          id: idx(['^id$','task id']),
          name: idx(['^name$','task name','nome','tarefa']),
          start: idx(['^start$','in[ií]cio','data inicial']),
          finish: idx(['^finish$','t[ée]rmino','data final','end']),
          pct: idx(['percent','%','concl','complete']),
          notes: idx(['notes','obs','observa']),
          bloco: idx(['bloco','setor']),
        };
      }

      function normalizeRow(row, map){
        const get = (i) => i>=0 && i<row.length ? row[i] : '';
        return {
          origId: String(get(map.id)||'').trim(),
          nome: String(get(map.name)||'').trim(),
          inicio: String(get(map.start)||'').trim(),
          fim: String(get(map.finish)||'').trim(),
          pct: Number(String(get(map.pct)||'0').toString().replace('%','').replace(',','.')) || 0,
          obs: String(get(map.notes)||'').trim(),
          bloco: (map.bloco>=0? String(get(map.bloco)).trim() : nameToBloco(String(get(map.name)))) || 'Todos',
        };
      }

      // ===== UI =====
      function Legend(){
        const Item = ({c,t}) => <div className="flex items-center gap-2 text-[11px]"><span className="inline-block w-3 h-3 rounded" style={{background:c}}/>{t}</div>;
        return (
          <div className="flex flex-wrap gap-3">
            <Item c={COLORS.bar} t="Em execução" />
            <Item c={COLORS.done} t="Concluído" />
            <Item c={COLORS.wait} t="Aguardando/Dependência" />
            <Item c={COLORS.hold} t="Hold/Não liberado" />
            <Item c={COLORS.risk} t="Em atraso" />
          </div>
        );
      }

      function DropCSV({ onData }){
        const [err, setErr] = useState('');
        const parse = (file) => {
          setErr('');
          Papa.parse(file, {
            complete: (res) => {
              try{
                const rows = res.data.filter(r=>r && r.length>0);
                const header = rows[0].map(x=>String(x));
                const map = autodetectColumns(header);
                if (map.name<0 || map.start<0 || map.finish<0){
                  setErr('Cabeçalho insuficiente. Inclua pelo menos: Name, Start, Finish.');
                  return;
                }
                const items = rows.slice(1).map(r=>normalizeRow(r, map)).filter(x=>x.nome);
                onData({ header, items });
              }catch(e){ setErr('Falha ao processar CSV.'); }
            },
            error: () => setErr('Erro ao ler CSV.'),
            skipEmptyLines: true
          });
        };
        return (
          <div>
            <label className="block text-[11px] text-slate-600 mb-1">Carregar CSV</label>
            <input type="file" accept=".csv" onChange={e=> e.target.files?.[0] && parse(e.target.files[0])}
              className="block w-full text-[12px] file:mr-3 file:px-3 file:py-1.5 file:rounded-lg file:border-0 file:bg-[#0e3a6d] file:text-white file:cursor-pointer" />
            <p className="text-[11px] text-slate-500 mt-1">Aceita export do MS Project/ProjectLibre. Cabeçalho típico: <i>ID, Name, Start, Finish, PercentComplete, Notes...</i></p>
            {err && <div className="mt-2 text-[11px] text-red-700">{err}</div>}
          </div>
        );
      }

      function MonthHeader({ spanDays, start, end }){
        const months = [];
        let cursor = new Date(start); cursor.setDate(1);
        while (cursor <= end){
          const mStart = new Date(cursor);
          const mEnd = new Date(cursor.getFullYear(), cursor.getMonth()+1, 0);
          const s = Math.max(mStart, start);
          const e = Math.min(mEnd, end);
          const width = ((e - s)/MS)/spanDays * 100;
          months.push({ key: `${cursor.getFullYear()}-${cursor.getMonth()}`, label: mStart.toLocaleDateString("pt-BR",{ month:"short", year:"2-digit"}), width });
          cursor = new Date(cursor.getFullYear(), cursor.getMonth()+1, 1);
        }
        return (
          <div className="flex w-full select-none sticky top-0 z-10" style={{gap:2, background: COLORS.card, borderBottom: `1px solid ${COLORS.border}`}}>
            {months.map(m => (
              <div key={m.key} className="text-[10px] uppercase tracking-wide text-slate-600 text-center" style={{width:`${m.width}%`}}>{m.label}</div>
            ))}
          </div>
        );
      }

      function GroupHeader({ title, tasks }){
        const arr = tasks.map(t => ({ days: Math.max(1, daysBetween(d(t.inicio), d(t.fim))), pct: clamp(t.pct??0,0,100) }));
        const totalDays = arr.reduce((s,x)=>s+x.days,0);
        const w = arr.reduce((s,x)=>s + x.days * x.pct, 0);
        const pv = totalDays? Math.round(w/totalDays): 0;
        const overdueCount = tasks.filter(t => (new Date(t.fim) < TODAY) && (t.pct??0) < 100).length;
        return (
          <div className="flex items-center justify-between px-3 py-1.5 bg-slate-50 border-b" style={{borderColor: COLORS.border}}>
            <div className="font-medium text-[12px]">{title}</div>
            <div className="flex items-center gap-2 text-[11px] text-slate-600">
              <span>Tarefas: <b>{tasks.length}</b></span>
              <span>Progresso (pond.): <b>{pv}%</b></span>
              <span className="px-2 py-0.5 rounded-full" style={{background: overdueCount?"#fee2e2":"#e2e8f0", color: overdueCount?"#991b1b":"#334155"}}>Atraso: {overdueCount}</span>
            </div>
          </div>
        );
      }

      // Badge de ID: visual mais leve (sem negrito exagerado)
      function IdBadge({ id }){
        return (
          <span className="inline-flex items-center justify-center rounded-md border border-slate-300 bg-white text-slate-700 px-2 py-0.5 font-normal leading-none tracking-tight" style={{minWidth:28}}>
            {id}
          </span>
        );
      }

      function TaskLeft({ t }){
        const s = statusFrom(t);
        const chipBg = { inprog:"#ebf3ff", wait:"#fff7e6", hold:"#f3e8ff", overdue:"#fee2e2", done:"#e6f7ec" }[s.k] || "#ebf3ff";
        const chipTx = { inprog:"#1e3a8a", wait:"#92400e", hold:"#6b21a8", overdue:"#991b1b", done:"#166534" }[s.k] || "#1e3a8a";
        return (
          <div className="pr-3 flex items-start gap-2">
            <IdBadge id={t.id} />
            <div>
              <div className="text-[11px] text-slate-500">{t.bloco}</div>
              <div className="text-[12px] font-medium flex items-center gap-2">
                {t.nome}
                <span className="px-1.5 py-0.5 rounded-full text-[10px]" style={{background: chipBg, color: chipTx}}>{s.label}</span>
              </div>
              {t.obs && <div className="text-[11px] italic mt-0.5 text-slate-600">{t.obs}</div>}
            </div>
          </div>
        );
      }

      function GanttBar({ task, spanDays, compact, start, end }){
        const a = d(task.inicio), b = d(task.fim);
        const left = clamp(((a - start)/MS)/spanDays * 100, -5, 105);
        const width = clamp(((b - a)/MS)/spanDays * 100, 0.2, 120);
        const pc = clamp(task.pct ?? 0, 0, 100);
        const color = barColor(task);
        const todayLeft = clamp(((TODAY - start)/MS)/spanDays * 100, -5, 105);
        const overdue = (TODAY > b) && pc < 100;
        const h = compact ? 18 : 22;

        return (
          <div className="group relative w-full">
            <div className="absolute" style={{left: `${todayLeft}%`, top: 0, bottom: 0}}>
              <div style={{width:2, background:"#11182722", height:"100%"}} />
            </div>
            <div className="relative rounded-lg shadow-sm" style={{ position:"relative", left:`${left}%`, width:`${width}%`, background: color, height:h, outline: overdue ? `2px solid ${COLORS.risk}` : "none" }}>
              <div style={{ width: `${pc}%`, background: "#00000022", height: "100%", borderRadius: 8 }} />
              <div className="absolute inset-0 flex items-center px-2 text-white text-[11px] font-medium drop-shadow">
                <span className="truncate">{task.nome}</span>
                <span className="ml-1 opacity-80">• {pc}%</span>
              </div>
            </div>
            <div className="mt-0.5 text-[10px] text-slate-600 flex flex-wrap items-center gap-2">
              <span>{fmt(a)} → {fmt(b)}</span>
              {task.obs && <span className="italic">· {task.obs}</span>}
              {overdue && <span className="px-1.5 py-0.5 rounded-full text-white" style={{background: COLORS.risk}}>{daysBetween(b, TODAY)}d em atraso</span>}
            </div>
          </div>
        );
      }

      function App(){
        const [data, setData] = useState({ header: [], items: [] });
        const [onlyEnergyB1, setOnlyEnergyB1] = useState(true);
        const [zoom, setZoom] = useState(100);
        const [compact, setCompact] = useState(true);
        const [orderBy, setOrderBy] = useState('inicio'); // define ordem para renumeração

        // Janela calculada a partir do CSV
        const [win, setWin] = useState({ start: DEFAULT_START, end: DEFAULT_END });
        useEffect(()=>{
          if (!data.items.length){ setWin({ start: DEFAULT_START, end: DEFAULT_END }); return; }
          const s = new Date(Math.min(...data.items.map(x=>d(x.inicio).getTime()).filter(x=>!isNaN(x))));
          const e = new Date(Math.max(...data.items.map(x=>d(x.fim).getTime()).filter(x=>!isNaN(x))));
          setWin({ start: isFinite(s) && !isNaN(s)? s : DEFAULT_START, end: isFinite(e) && !isNaN(e)? e : DEFAULT_END });
        }, [data]);

        // 1) Constrói tasks base a partir do CSV
        const baseTasks = useMemo(()=> data.items.map((x,idx)=>({ id: idx, bloco: x.bloco||'Todos', nome: x.nome, inicio: x.inicio, fim: x.fim, pct: x.pct||0, obs: x.obs||'' })), [data]);

        // 2) Aplica regra opcional do Bloco 1
        const filtered = useMemo(()=> baseTasks.filter(t => !onlyEnergyB1 || t.bloco !== 'Bloco 1' || isEnergyB1(t)), [baseTasks, onlyEnergyB1]);

        // 3) Ordena e RENUMERA IDs sempre em ordem crescente
        const tasks = useMemo(()=> {
          const sorted = [...filtered].sort((a,b)=>{
            if (orderBy==='nome') return a.nome.localeCompare(b.nome, 'pt-BR');
            // default: início, depois nome
            const da = d(a.inicio)-d(b.inicio);
            return da!==0 ? da : a.nome.localeCompare(b.nome, 'pt-BR');
          });
          return sorted.map((t, idx)=>({ ...t, id: idx }));
        }, [filtered, orderBy]);

        const spanDaysBase = Math.max(1, Math.round((win.end - win.start) / MS));
        const spanDays = Math.round(spanDaysBase / (zoom / 100));

        const groups = useMemo(() => {
          const map = new Map();
          tasks.forEach(t => {
            if (!map.has(t.bloco)) map.set(t.bloco, []);
            map.get(t.bloco).push(t);
          });
          const order = ["Bloco 1","Bloco 2","Bloco 3","Embasamento","Todos"]; // macro no fim
          return order.filter(k=>map.has(k)).map(k=>[k,map.get(k)]);
        }, [tasks]);

        const progressoGeral = useMemo(() => {
          if (!tasks.length) return 0;
          const arr = tasks.map(t => ({ days: Math.max(1, Math.round((d(t.fim)-d(t.inicio))/MS)), pct: clamp(t.pct??0,0,100) }));
          const totalDays = arr.reduce((s,x)=>s+x.days,0);
          const w = arr.reduce((s,x)=>s + x.days * x.pct, 0);
          return Math.round(w/totalDays);
        }, [tasks]);

        return (
          <div className="min-h-screen" style={{background: COLORS.bg, color: COLORS.text}}>
            <div className="max-w-7xl mx-auto px-3 py-4">
              <header className="flex flex-wrap items-center justify-between gap-3 mb-3">
                <div className="flex items-center gap-2">
                  <div className="h-8 w-8 rounded bg-[#0e3a6d]"/>
                  <div>
                    <h1 className="text-lg font-extrabold">Atlântico Golf — Cronograma (CSV)</h1>
                    <p className="text-slate-600 text-[11px]">Janela: {fmt(win.start)} → {fmt(win.end)} · Progresso médio ponderado: <b>{progressoGeral}%</b></p>
                  </div>
                </div>
                <div className="flex flex-col items-end">
                  <Legend />
                  <div className="text-[11px] text-slate-600 mt-1">Linha vertical indica <b>hoje</b>: {fmt(TODAY)}</div>
                </div>
              </header>

              <section className="mb-4 grid gap-3 md:grid-cols-2">
                <div className="rounded-xl border p-3 bg-white" style={{borderColor: COLORS.border}}>
                  <DropCSV onData={setData} />
                  <div className="mt-3 flex flex-wrap items-center gap-3">
                    <label className="flex items-center gap-2 text-[11px] text-slate-700">
                      <input type="checkbox" checked={onlyEnergyB1} onChange={e=>setOnlyEnergyB1(e.target.checked)} /> Bloco 1: apenas Entrada de Energia
                    </label>
                    <label className="flex items-center gap-2 text-[11px] text-slate-700">
                      Ordenar por
                      <select className="px-2 py-1 rounded border" value={orderBy} onChange={e=>setOrderBy(e.target.value)}>
                        <option value="inicio">Início</option>
                        <option value="nome">Nome</option>
                      </select>
                      (IDs são reindexados após a ordenação)
                    </label>
                  </div>
                </div>

                <div className="rounded-xl border p-3 bg-white" style={{borderColor: COLORS.border}}>
                  <div className="flex flex-wrap items-center gap-3">
                    <label className="flex items-center gap-2 text-[11px] text-slate-700">
                      Zoom
                      <input type="range" min={25} max={200} value={zoom} onChange={e=>setZoom(Number(e.target.value))} />
                      <span>{zoom}%</span>
                    </label>
                    <label className="flex items-center gap-2 text-[11px] text-slate-700">
                      <input type="checkbox" checked={compact} onChange={e=>setCompact(e.target.checked)} /> Modo compacto
                    </label>
                    <a href="#" className="text-[11px] underline" onClick={(e)=>{ e.preventDefault();
                      // exporta CSV normalizado
                      const header = ['ID','Bloco','Tarefa','Início','Término','Percentual','Status','Observação'];
                      const rows = tasks.map(t=>{
                        const s = statusFrom(t);
                        return [t.id, t.bloco, t.nome, t.inicio, t.fim, t.pct, s.label, t.obs||''];
                      });
                      const csv = [header, ...rows].map(r=>r.map(x=>`"${String(x).replace(/"/g,'""')}"`).join(',')).join('\n');
                      const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
                      const url = URL.createObjectURL(blob);
                      const a = document.createElement('a'); a.href=url; a.download='cronograma-normalizado.csv'; a.click(); URL.revokeObjectURL(url);
                    }}>Baixar CSV normalizado</a>
                  </div>
                  <p className="text-[11px] text-slate-500 mt-2">IDs sempre sequenciais em ordem crescente após filtros/ordenação.</p>
                </div>
              </section>

              <section className="rounded-xl shadow border overflow-hidden" style={{background: COLORS.card, borderColor: COLORS.border}}>
                <MonthHeader spanDays={Math.max(1, Math.round((win.end - win.start)/MS)/(zoom/100))} start={win.start} end={win.end} />
                {tasks.length===0 ? (
                  <div className="p-6 text-slate-500">Nenhum dado carregado. Importe um CSV para visualizar o cronograma.</div>
                ) : (
                  ["Bloco 1","Bloco 2","Bloco 3","Embasamento","Todos"].map(gr => {
                    const itens = tasks.filter(t=>t.bloco===gr);
                    if (!itens.length) return null;
                    return (
                      <div key={gr} className="border-b" style={{borderColor: COLORS.border}}>
                        <GroupHeader title={gr} tasks={itens} />
                        <div className="divide-y" style={{borderColor: COLORS.border}}>
                          {itens.map(t => (
                            <div key={t.id} className="p-2 grid" style={{gridTemplateColumns: '62px 260px 1fr'}}>
                              <div className="flex items-start"><IdBadge id={t.id} /></div>
                              <TaskLeft t={t} />
                              <GanttBar task={t} spanDays={Math.max(1, Math.round((win.end - win.start)/MS)/(zoom/100))} compact={compact} start={win.start} end={win.end} />
                            </div>
                          ))}
                        </div>
                      </div>
                    );
                  })
                )}
              </section>

              <section className="mt-5">
                <details className="rounded-xl border p-3 bg-white">
                  <summary className="cursor-pointer font-medium text-[12px]">Ver tabela (dados brutos)</summary>
                  <div className="overflow-x-auto mt-2">
                    <table className="min-w-full text-[12px]">
                      <thead>
                        <tr className="text-left border-b">
                          <th className="py-1.5 pr-3">ID</th>
                          <th className="py-1.5 pr-3">Bloco</th>
                          <th className="py-1.5 pr-3">Tarefa</th>
                          <th className="py-1.5 pr-3">Início</th>
                          <th className="py-1.5 pr-3">Término</th>
                          <th className="py-1.5 pr-3">% Concl.</th>
                          <th className="py-1.5 pr-3">Status</th>
                          <th className="py-1.5 pr-3">Observação</th>
                        </tr>
                      </thead>
                      <tbody>
                        {tasks.map(t => {
                          const s = statusFrom(t);
                          return (
                            <tr key={`tb-${t.id}`} className="border-b last:border-0">
                              <td className="py-1 pr-3">{t.id}</td>
                              <td className="py-1 pr-3">{t.bloco}</td>
                              <td className="py-1 pr-3">{t.nome}</td>
                              <td className="py-1 pr-3">{t.inicio}</td>
                              <td className="py-1 pr-3">{t.fim}</td>
                              <td className="py-1 pr-3">{t.pct}%</td>
                              <td className="py-1 pr-3">{s.label}</td>
                              <td className="py-1 pr-3">{t.obs||""}</td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  </div>
                </details>
              </section>

              <footer className="mt-6 text-[11px] text-slate-500">
                <div>• Suba um <b>CSV</b> exportado do Project. As colunas são detectadas automaticamente.</div>
                <div>• IDs são <b>sempre</b> renumerados (0..N-1) após filtros/ordem escolhida. Visual do ID foi suavizado (chip leve, sem negrito exagerado).</div>
              </footer>
            </div>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>

